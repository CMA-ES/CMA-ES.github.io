<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>cma.evolution_strategy.CMAEvolutionStrategy : API documentation</title>

    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link type="text/css" href="bootstrap.min.css" rel="stylesheet" />
    <link type="text/css" href="apidocs.css" rel="stylesheet" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a href="index.html" class="navbar-brand">
            cma API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button onclick="togglePrivate()" class="btn btn-link">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code>cma.evolution_strategy.CMAEvolutionStrategy(<span title=".interfaces.OOOptimizer">interfaces.OOOptimizer</span>)</code> <small>class documentation</small></h1>

        <span id="partOf">
          Part of <code><a href="cma.html" data-type="Package" class="code">cma</a>.<a href="cma.evolution_strategy.html" data-type="Module" class="code">evolution_strategy</a></code>
          
          <a href="classIndex.html#cma.evolution_strategy.CMAEvolutionStrategy">(View In Hierarchy)</a>
        </span>
      </div>

      <div class="extrasDocstring">
        
      </div>

      <div class="moduleDocstring">
        <div><p>CMA-ES stochastic optimizer class with ask-and-tell interface.</p>
<div class="rst-section" id="rst-calling-sequences">
<h1 class="heading">Calling Sequences</h1>
<ul>
<li><p class="rst-first"><tt class="rst-docutils literal">es = CMAEvolutionStrategy(x0, sigma0)</tt></p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">es = CMAEvolutionStrategy(x0, sigma0, opts)</tt></p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">es = CMAEvolutionStrategy(x0, <span class="pre">sigma0).optimize(objective_fct)</span></tt></p>
</li>
<li><pre class="rst-first rst-literal-block">
res = CMAEvolutionStrategy(x0, sigma0,
                        opts).optimize(objective_fct).result
</pre>
</li>
</ul>
</div>
<div class="rst-section" id="rst-arguments">
<h1 class="heading">Arguments</h1>
<dl class="rst-docutils">
<dt><code>x0</code></dt>
<dd><p class="rst-first">initial solution, starting point. <code>x0</code> is given as "phenotype"
which means, if:</p>
<pre class="rst-literal-block">
opts = {'transformation': [transform, inverse]}
</pre>
<p class="rst-last">is given and <tt class="rst-docutils literal">inverse is None</tt>, the initial mean is not
consistent with <code>x0</code> in that <tt class="rst-docutils literal">transform(mean)</tt> does not
equal to <code>x0</code> unless <tt class="rst-docutils literal">transform(mean)</tt> equals <tt class="rst-docutils literal">mean</tt>.</p>
</dd>
<dt><code>sigma0</code></dt>
<dd>initial standard deviation.  The problem variables should
have been scaled, such that a single standard deviation
on all variables is useful and the optimum is expected to
lie within about <code>x0</code> +- <tt class="rst-docutils literal">3*sigma0</tt>. Often one wants to
check for solutions close to the initial point. This allows,
for example, for an easier check of consistency of the
objective function and its interfacing with the optimizer.
In this case, a much smaller <code>sigma0</code> is advisable.</dd>
<dt><code>opts</code></dt>
<dd>options, a dictionary with optional settings,
see class <a href="cma.evolution_strategy.CMAOptions.html"><code>CMAOptions</code></a>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-main-interface-usage">
<h1 class="heading">Main interface / usage</h1>
<p>The interface is inherited from the generic <a href="cma.interfaces.OOOptimizer.html"><code>OOOptimizer</code></a>
class (see also there). An object instance is generated from:</p>
<pre class="rst-literal-block">
es = cma.CMAEvolutionStrategy(8 * [0.5], 0.2)
</pre>
<p>The least verbose interface is via the optimize method:</p>
<pre class="rst-literal-block">
es.optimize(objective_func)
res = es.result
</pre>
<p>More verbosely, the optimization is done using the
methods <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#stop"><code>stop</code></a>, <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask"><code>ask</code></a>, and <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#tell"><code>tell</code></a>:</p>
<pre class="rst-literal-block">
while not es.stop():
    solutions = es.ask()
    es.tell(solutions, [cma.ff.rosen(s) for s in solutions])
    es.disp()
es.result_pretty()
</pre>
<p>where <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask"><code>ask</code></a> delivers new candidate solutions and <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#tell"><code>tell</code></a> updates
the <code>optim</code> instance by passing the respective function values
(the objective function <code>cma.ff.rosen</code> can be replaced by any
properly defined objective function, see <code>cma.ff</code> for more
examples).</p>
<p>To change an option, for example a termination condition to
continue the optimization, call:</p>
<pre class="rst-literal-block">
es.opts.set({'tolfacupx': 1e4})
</pre>
<p>The class <a href="cma.evolution_strategy.CMAEvolutionStrategy.html"><code>CMAEvolutionStrategy</code></a> also provides:</p>
<pre class="rst-literal-block">
(solutions, func_values) = es.ask_and_eval(objective_func)
</pre>
<p>and an entire optimization can also be written like:</p>
<pre class="rst-literal-block">
while not es.stop():
    es.tell(*es.ask_and_eval(objective_func))
</pre>
<p>Besides for termination criteria, in CMA-ES only the ranks of the
<code>func_values</code> are relevant.</p>
</div>
<div class="rst-section" id="rst-attributes-and-properties">
<h1 class="heading">Attributes and Properties</h1>
<ul class="rst-simple">
<li><code>inputargs</code>: passed input arguments</li>
<li><code>inopts</code>: passed options</li>
<li><code>opts</code>: actually used options, some of them can be changed any
time via <tt class="rst-docutils literal">opts.set</tt>, see class <a href="cma.evolution_strategy.CMAOptions.html"><code>CMAOptions</code></a></li>
<li><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#popsize"><code>popsize</code></a>: population size lambda, number of candidate
solutions returned by <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask"><code>ask</code></a> ()</li>
<li><a href="cma.logger.html"><code>logger</code></a>: a <a href="cma.logger.CMADataLogger.html"><code>CMADataLogger</code></a> instance utilized by <code>optimize</code></li>
</ul>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<p>Super-short example, with output shown:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> cma
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># construct an object instance in 4-D, sigma0=1:</span>
<span class="py-prompt">&gt;&gt;&gt; </span>es = cma.CMAEvolutionStrategy(4 * [1], 1, {<span class="py-string">'seed'</span>:234})
<span class="py-more">... </span>     <span class="py-comment"># doctest: +ELLIPSIS</span>
<span class="py-output">(4_w,8)-aCMA-ES (mu_w=2.6,w_1=52%) in dimension 4 (seed=234...)</span></pre>
<p>and optimize the ellipsoid function</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>es.optimize(cma.ff.elli, verb_disp=1)  <span class="py-comment"># doctest: +ELLIPSIS</span>
<span class="py-output">Iterat #Fevals   function value  axis ratio  sigma  min&amp;max std  t[m:s]</span>
<span class="py-output">    1      8 2.09...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>assert <span class="py-builtin">len</span>(es.result) == 8
<span class="py-prompt">&gt;&gt;&gt; </span>assert es.result[1] &lt; 1e-9</pre>
<p>The optimization loop can also be written explicitly:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>es = cma.CMAEvolutionStrategy(4 * [1], 1)  <span class="py-comment"># doctest: +ELLIPSIS</span>
<span class="py-output">(4_w,8)-aCMA-ES (mu_w=2.6,w_1=52%) in dimension 4 (seed=...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>while <span class="py-keyword">not</span> es.stop():
<span class="py-more">... </span>   X = es.ask()
<span class="py-more">... </span>   es.tell(X, [cma.ff.elli(x) <span class="py-keyword">for</span> x <span class="py-keyword">in</span> X])
<span class="py-more">... </span>   es.disp()  <span class="py-comment"># doctest: +ELLIPSIS</span>
<span class="py-output">Iterat #Fevals   function value  axis ratio  sigma  min&amp;max std  t[m:s]</span>
<span class="py-output">    1      8 ...</span></pre>
<p>achieving the same result as above.</p>
<p>An example with lower bounds (at zero) and handling infeasible
solutions:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> numpy <span class="py-keyword">as</span> np
<span class="py-prompt">&gt;&gt;&gt; </span>es = cma.CMAEvolutionStrategy(10 * [0.2], 0.5,
<span class="py-more">... </span>        {<span class="py-string">'bounds'</span>: [0, np.inf]})  <span class="py-comment">#doctest: +ELLIPSIS</span>
<span class="py-output">(5_w,...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>while <span class="py-keyword">not</span> es.stop():
<span class="py-more">... </span>    fit, X = [], []
<span class="py-more">... </span>    while <span class="py-builtin">len</span>(X) &lt; es.popsize:
<span class="py-more">... </span>        curr_fit = <span class="py-builtin">None</span>
<span class="py-more">... </span>        while curr_fit <span class="py-keyword">in</span> (<span class="py-builtin">None</span>, np.NaN):
<span class="py-more">... </span>            x = es.ask(1)[0]
<span class="py-more">... </span>            curr_fit = cma.ff.somenan(x, cma.ff.elli) <span class="py-comment"># might return np.NaN</span>
<span class="py-more">... </span>        X.append(x)
<span class="py-more">... </span>        fit.append(curr_fit)
<span class="py-more">... </span>    es.tell(X, fit)
<span class="py-more">... </span>    es.logger.add()
<span class="py-more">... </span>    es.disp()  <span class="py-comment">#doctest: +ELLIPSIS</span>
<span class="py-output">Itera...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span>assert es.result[1] &lt; 1e-9
<span class="py-prompt">&gt;&gt;&gt; </span>assert es.result[2] &lt; 9000  <span class="py-comment"># by internal termination</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># es.logger.plot()  # will plot data</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># cma.s.figshow()  # display plot window</span></pre>
<p>An example with user-defined transformation, in this case to realize
a lower bound of 2.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> warnings
<span class="py-prompt">&gt;&gt;&gt; </span>with warnings.catch_warnings(record=<span class="py-builtin">True</span>) <span class="py-keyword">as</span> warns:
<span class="py-more">... </span>    es = cma.CMAEvolutionStrategy(5 * [3], 0.1,
<span class="py-more">... </span>                {<span class="py-string">"transformation"</span>: [<span class="py-keyword">lambda</span> x: x**2+1.2, <span class="py-builtin">None</span>],
<span class="py-more">... </span>                 <span class="py-string">"verbose"</span>: -2,})
<span class="py-prompt">&gt;&gt;&gt; </span>warns[0].message  <span class="py-comment"># doctest:+ELLIPSIS</span>
<span class="py-output">UserWarning('in class GenoPheno: user defined transformations have not been tested thoroughly ()'...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>warns[1].message  <span class="py-comment"># doctest:+ELLIPSIS</span>
<span class="py-output">UserWarning('computed initial point...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>es.optimize(cma.ff.rosen, verb_disp=0)  <span class="py-comment">#doctest: +ELLIPSIS</span>
<span class="py-output">&lt;cma...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>assert cma.ff.rosen(es.result[0]) &lt; 1e-7 + 5.54781521192
<span class="py-prompt">&gt;&gt;&gt; </span>assert es.result[2] &lt; 3300</pre>
<p>The inverse transformation is (only) necessary if the <a href="cma.constraints_handler.BoundPenalty.html"><code>BoundPenalty</code></a>
boundary handler is used at the same time.</p>
<p>The <a href="cma.evolution_strategy.CMAEvolutionStrategy.html"><code>CMAEvolutionStrategy</code></a> class also provides a default logger
(cave: files are overwritten when the logger is used with the same
filename prefix):</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>es = cma.CMAEvolutionStrategy(4 * [0.2], 0.5, {<span class="py-string">'verb_disp'</span>: 0})
<span class="py-prompt">&gt;&gt;&gt; </span>es.logger.disp_header()  <span class="py-comment"># annotate the print of disp</span>
<span class="py-output">Iterat Nfevals  function value    axis ratio maxstd  minstd</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>while <span class="py-keyword">not</span> es.stop():
<span class="py-more">... </span>    X = es.ask()
<span class="py-more">... </span>    es.tell(X, [cma.ff.sphere(x) <span class="py-keyword">for</span> x <span class="py-keyword">in</span> X])
<span class="py-more">... </span>    es.logger.add()  <span class="py-comment"># log current iteration</span>
<span class="py-more">... </span>    es.logger.disp([-1])  <span class="py-comment"># display info for last iteration   #doctest: +ELLIPSIS</span>
<span class="py-output">    1  ...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>es.logger.disp_header()
<span class="py-output">Iterat Nfevals  function value    axis ratio maxstd  minstd</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># es.logger.plot() # will make a plot</span></pre>
<p>Example implementing restarts with increasing popsize (IPOP):</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>bestever = cma.optimization_tools.BestSolution()
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> lam <span class="py-keyword">in</span> 10 * 2**np.arange(8):  <span class="py-comment"># 10, 20, 40, 80, ..., 10 * 2**7</span>
<span class="py-more">... </span>    es = cma.CMAEvolutionStrategy(6 - 8 * np.random.rand(4),  <span class="py-comment"># 4-D</span>
<span class="py-more">... </span>                                  5,  <span class="py-comment"># initial std sigma0</span>
<span class="py-more">... </span>                                  {<span class="py-string">'popsize'</span>: lam,  <span class="py-comment"># options</span>
<span class="py-more">... </span>                                   <span class="py-string">'verb_append'</span>: bestever.evalsall})
<span class="py-more">... </span>    <span class="py-comment"># logger = cma.CMADataLogger().register(es, append=bestever.evalsall)</span>
<span class="py-more">... </span>    while <span class="py-keyword">not</span> es.stop():
<span class="py-more">... </span>        X = es.ask()    <span class="py-comment"># get list of new solutions</span>
<span class="py-more">... </span>        fit = [cma.ff.rastrigin(x) <span class="py-keyword">for</span> x <span class="py-keyword">in</span> X]  <span class="py-comment"># evaluate each solution</span>
<span class="py-more">... </span>        es.tell(X, fit) <span class="py-comment"># besides for termination only the ranking in fit is used</span>
<span class="py-more">...</span>
<span class="py-more">... </span>        <span class="py-comment"># display some output</span>
<span class="py-more">... </span>        <span class="py-comment"># logger.add()  # add a "data point" to the log, writing in files</span>
<span class="py-more">... </span>        es.disp()  <span class="py-comment"># uses option verb_disp with default 100</span>
<span class="py-more">...</span>
<span class="py-more">... </span>    <span class="py-keyword">print</span>(<span class="py-string">'termination:'</span>, es.stop())
<span class="py-more">... </span>    cma.s.pprint(es.best.__dict__)
<span class="py-more">...</span>
<span class="py-more">... </span>    bestever.update(es.best)
<span class="py-more">...</span>
<span class="py-more">... </span>    <span class="py-comment"># show a plot</span>
<span class="py-more">... </span>    <span class="py-comment"># logger.plot();</span>
<span class="py-more">... </span>    <span class="py-keyword">if</span> bestever.f &lt; 1e-8:  <span class="py-comment"># global optimum was hit</span>
<span class="py-more">... </span>        break  <span class="py-comment">#doctest: +ELLIPSIS</span>
<span class="py-output">(5_w,...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>assert es.result[1] &lt; 1e-8</pre>
<p>On the Rastrigin function, usually after five restarts the global
optimum is located.</p>
<p>Using the <a href="http://docs.python.org/library/multiprocessing.html#multiprocessing"><code>multiprocessing</code></a> module, we can evaluate the function in
parallel with a simple modification of the example (however
multiprocessing seems not always reliable):</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> cma.fitness_functions <span class="py-keyword">import</span> elli  <span class="py-comment"># cannot be an instance method</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> cma.fitness_transformations <span class="py-keyword">import</span> EvalParallel2
<span class="py-prompt">&gt;&gt;&gt; </span>es = cma.CMAEvolutionStrategy(22 * [0.0], 1.0, {<span class="py-string">'maxiter'</span>:10})  <span class="py-comment"># doctest:+ELLIPSIS</span>
<span class="py-output">(6_w,13)-aCMA-ES (mu_w=...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>with EvalParallel2(elli, es.popsize + 1) <span class="py-keyword">as</span> eval_all:
<span class="py-more">... </span>    while <span class="py-keyword">not</span> es.stop():
<span class="py-more">... </span>        X = es.ask()
<span class="py-more">... </span>        es.tell(X, eval_all(X))
<span class="py-more">... </span>        es.disp()
<span class="py-more">... </span>        <span class="py-comment"># es.logger.add()  # doctest:+ELLIPSIS</span>
<span class="py-output">Iterat...</span></pre>
<p>The final example shows how to resume:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> pickle
<span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span>es0 = cma.CMAEvolutionStrategy(12 * [0.1],  <span class="py-comment"># a new instance, 12-D</span>
<span class="py-more">... </span>                               0.12)         <span class="py-comment"># initial std sigma0</span>
<span class="py-more">... </span>  <span class="py-comment">#doctest: +ELLIPSIS</span>
<span class="py-output">(5_w,...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>es0.optimize(cma.ff.rosen, iterations=100)  <span class="py-comment">#doctest: +ELLIPSIS</span>
<span class="py-output">I...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>s = es0.pickle_dumps()  <span class="py-comment"># return pickle.dumps(es) with safeguards</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># save string s to file like open(filename, 'wb').write(s)</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">del</span> es0  <span class="py-comment"># let's start fresh</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># s = open(filename, 'rb').read()  # load string s from file</span>
<span class="py-prompt">&gt;&gt;&gt; </span>es = pickle.loads(s)  <span class="py-comment"># read back es instance from string</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># resuming</span>
<span class="py-prompt">&gt;&gt;&gt; </span>es.optimize(cma.ff.rosen, verb_disp=200)  <span class="py-comment">#doctest: +ELLIPSIS</span>
<span class="py-output">  200 ...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>assert es.result[2] &lt; 15000
<span class="py-prompt">&gt;&gt;&gt; </span>assert cma.s.Mh.vequals_approximately(es.result[0], 12 * [1], 1e-5)
<span class="py-prompt">&gt;&gt;&gt; </span>assert <span class="py-builtin">len</span>(es.result) == 8</pre>
</div>
<div class="rst-section" id="rst-details">
<h1 class="heading">Details</h1>
<p>The following two enhancements are implemented, the latter is turned
on by default for very small population size only.</p>
<p><em>Active CMA</em> is implemented with option <tt class="rst-docutils literal">CMA_active</tt> and
conducts an update of the covariance matrix with negative weights.
The negative update is implemented, such that positive definiteness
is guarantied. A typical speed up factor (number of f-evaluations)
is between 1.1 and two.</p>
<p>References: Jastrebski and Arnold, Improving evolution strategies
through active covariance matrix adaptation, CEC 2006.
Hansen, The CMA evolution strategy: a tutorial, arXiv 2016.</p>
<p><em>Selective mirroring</em> is implemented with option <tt class="rst-docutils literal">CMA_mirrors</tt>
in the method <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#get_mirror"><code>get_mirror</code></a> and <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#get_selective_mirrors"><code>get_selective_mirrors</code></a>.
The method <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask_and_eval"><code>ask_and_eval</code></a> (used by <a href="cma.evolution_strategy.html#fmin"><code>fmin</code></a>) will then sample
selectively mirrored vectors within the iteration
(<tt class="rst-docutils literal"><span class="pre">CMA_mirrormethod==1</span></tt>). Otherwise, or if <tt class="rst-docutils literal"><span class="pre">CMA_mirromethod==2</span></tt>,
selective mirrors are injected for the next iteration.
In selective mirroring, only the worst solutions are  mirrored. With
the default small number of mirrors, <em>pairwise selection</em> (where at
most one of the two mirrors contribute to the update of the
distribution mean) is implicitly guarantied under selective
mirroring and therefore not explicitly implemented.</p>
<p>References: Brockhoff et al, PPSN 2010, Auger et al, GECCO 2011.</p>
</div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><a href="cma.evolution_strategy.html#fmin"><code>fmin</code></a> (), <a href="cma.interfaces.OOOptimizer.html"><code>OOOptimizer</code></a>, <a href="cma.evolution_strategy.CMAOptions.html"><code>CMAOptions</code></a>, <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#plot"><code>plot</code></a> (), <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask"><code>ask</code></a> (),
<a href="cma.evolution_strategy.CMAEvolutionStrategy.html#tell"><code>tell</code></a> (), <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask_and_eval"><code>ask_and_eval</code></a> ()</td></tr></table></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id370">
  
  <tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#popsize" data-type="Method" class="code">popsize</a></td>
    <td><span>number of samples by default returned by <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask"><code>ask</code></a> ()</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#stop" data-type="Method" class="code">stop</a></td>
    <td><span>return the termination status as dictionary.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#__init__" data-type="Method" class="code">__init__</a></td>
    <td><span>see class <a href="cma.evolution_strategy.CMAEvolutionStrategy.html"><code>CMAEvolutionStrategy</code></a></span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask" data-type="Method" class="code">ask</a></td>
    <td><span>get/sample new candidate solutions.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask_geno" data-type="Method" class="code">ask_geno</a></td>
    <td><span>get new candidate solutions in genotyp.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#random_rescale_to_mahalanobis" data-type="Method" class="code">random_rescale_to_mahalanobis</a></td>
    <td><span>change <code>x</code> like for injection, all on genotypic level</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#get_mirror" data-type="Method" class="code">get_mirror</a></td>
    <td><span>return <tt class="rst-docutils literal">pheno(self.mean - (geno(x) - self.mean))</tt>.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask_and_eval" data-type="Method" class="code">ask_and_eval</a></td>
    <td><span>sample <code>number</code> solutions and evaluate them on <code>func</code>.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#get_selective_mirrors" data-type="Method" class="code">get_selective_mirrors</a></td>
    <td><span>get mirror genotypic directions from worst solutions.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#tell" data-type="Method" class="code">tell</a></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#inject" data-type="Method" class="code">inject</a></td>
    <td><span>inject list of one or several genotypic solution(s).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#result" data-type="Method" class="code">result</a></td>
    <td><span>return a <a href="cma.evolution_strategy.CMAEvolutionStrategyResult.html"><code>CMAEvolutionStrategyResult</code></a> <code>namedtuple</code>.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#result_pretty" data-type="Method" class="code">result_pretty</a></td>
    <td><span>pretty print result.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#pickle_dumps" data-type="Method" class="code">pickle_dumps</a></td>
    <td><span>return <tt class="rst-docutils literal">pickle.dumps(self)</tt>,</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#repair_genotype" data-type="Method" class="code">repair_genotype</a></td>
    <td><span>make sure that solutions fit to the sample distribution.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#manage_plateaus" data-type="Method" class="code">manage_plateaus</a></td>
    <td><span>increase <code>sigma</code> by <code>sigma_fac</code> in case of a plateau.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#condition_number" data-type="Method" class="code">condition_number</a></td>
    <td><span>condition number of the statistical-model sampler.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#alleviate_conditioning_in_coordinates" data-type="Method" class="code">alleviate_conditioning_in_coordinates</a></td>
    <td><span>pass scaling from <code>C</code> to <code>sigma_vec</code>.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#alleviate_conditioning" data-type="Method" class="code">alleviate_conditioning</a></td>
    <td><span>pass conditioning of <code>C</code> to linear transformation in <code>self.gp</code>.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#feed_for_resume" data-type="Method" class="code">feed_for_resume</a></td>
    <td><span>Resume a run using the solution history.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#mahalanobis_norm" data-type="Method" class="code">mahalanobis_norm</a></td>
    <td><span>return Mahalanobis norm based on the current sample distribution.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#isotropic_mean_shift" data-type="Method" class="code">isotropic_mean_shift</a></td>
    <td><span>normalized last mean shift, under random selection N(0,I)</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#disp_annotation" data-type="Method" class="code">disp_annotation</a></td>
    <td><span>print annotation line for <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#disp"><code>disp</code></a> ()</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#disp" data-type="Method" class="code">disp</a></td>
    <td><span>print current state variables in a single-line.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#plot" data-type="Method" class="code">plot</a></td>
    <td><span>plot current state variables using <code>matplotlib</code>.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#_set_x0" data-type="Method" class="code">_set_x0</a></td>
    <td><span>Assign <code>self.x0</code> from argument <code>x0</code>.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#_copy_light" data-type="Method" class="code">_copy_light</a></td>
    <td><span>tentative copy of self, versatile (interface and functionalities may change).</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#_random_rescaling_factor_to_mahalanobis_size" data-type="Method" class="code">_random_rescaling_factor_to_mahalanobis_size</a></td>
    <td><span><tt class="rst-docutils literal">self.mean + self._random_rescaling_factor_to_mahalanobis_size(y) * y</tt> is guarantied to appear like from the sample distribution.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#_prepare_injection_directions" data-type="Method" class="code">_prepare_injection_directions</a></td>
    <td><span>provide genotypic directions for TPA and selective mirroring, with no specific length normalization, to be used in the coming iteration.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#_tfp" data-type="Method" class="code">_tfp</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#_tfg" data-type="Method" class="code">_tfg</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#_updateBDfromSM" data-type="Method" class="code">_updateBDfromSM</a></td>
    <td><span>helper function for a smooth transition to sampling classes.</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.popsize">
    
  </a>
  <a name="popsize">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    popsize(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>number of samples by default returned by <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask"><code>ask</code></a> ()<table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.stop">
    
  </a>
  <a name="stop">
    
  </a>
  <div class="functionHeader">
    
    def
    stop(self, check=True, ignore_list=(), check_in_same_iteration=False, get_value=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>return the termination status as dictionary.</p>
<p>With <tt class="rst-docutils literal">check == False</tt>, the termination conditions are not checked
and the status might not reflect the current situation.
<tt class="rst-docutils literal">check_on_same_iteration == False</tt> (new) does not re-check during
the same iteration. When termination options are manually changed,
it must be set to <a href="http://docs.python.org/library/constants.html#True"><code>True</code></a> to advance afterwards.
<tt class="rst-docutils literal"><span class="pre">stop().clear()</span></tt> removes the currently active termination
conditions.</p>
<p>As a convenience feature, keywords in <code>ignore_list</code> are removed from
the conditions.</p>
<p>If <code>get_value</code> is set to a condition name (not the empty string),
<a href="cma.evolution_strategy.CMAEvolutionStrategy.html#stop"><code>stop</code></a> does not update the termination dictionary but returns the
measured value that would be compared to the threshold. This only
works for some conditions, like 'tolx'. If the condition name is
not known or cannot be computed, <a href="http://docs.python.org/library/constants.html#None"><code>None</code></a> is returned and no warning
is issued.</p>
<p>Testing <code>get_value</code> functionality:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> cma
<span class="py-prompt">&gt;&gt;&gt; </span>es = cma.CMAEvolutionStrategy(2 * [1], 1e4, {<span class="py-string">'verbose'</span>: -9})
<span class="py-prompt">&gt;&gt;&gt; </span>with warnings.catch_warnings(record=<span class="py-builtin">True</span>) <span class="py-keyword">as</span> w:
<span class="py-more">... </span>    es.stop(get_value=<span class="py-string">'tolx'</span>)  <span class="py-comment"># triggers zero iteration warning</span>
<span class="py-more">... </span>    assert <span class="py-builtin">len</span>(w) == 1, [<span class="py-builtin">str</span>(wi) <span class="py-keyword">for</span> wi <span class="py-keyword">in</span> w]
<span class="py-prompt">&gt;&gt;&gt; </span>es = es.optimize(cma.ff.sphere, iterations=4)
<span class="py-prompt">&gt;&gt;&gt; </span>assert 1e3 &lt; es.stop(get_value=<span class="py-string">'tolx'</span>) &lt; 1e4, es.stop(get_value=<span class="py-string">'tolx'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>assert es.stop() == {}
<span class="py-prompt">&gt;&gt;&gt; </span>assert es.stop(get_value=<span class="py-string">'catch 22'</span>) <span class="py-keyword">is</span> <span class="py-builtin">None</span></pre><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    def
    __init__(self, x0, sigma0, inopts=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>see class <a href="cma.evolution_strategy.CMAEvolutionStrategy.html"><code>CMAEvolutionStrategy</code></a><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy._set_x0">
    
  </a>
  <a name="_set_x0">
    
  </a>
  <div class="functionHeader">
    
    def
    _set_x0(self, x0):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Assign <code>self.x0</code> from argument <code>x0</code>.</p>
<p>Input <code>x0</code> may be a <a href="http://docs.python.org/library/functions.html#callable"><code>callable</code></a> or a <a href="http://docs.python.org/library/stdtypes.html#list"><code>list</code></a> or <code>numpy.ndarray</code> of
the desired length.</p>
<p>Below an artificial example is given, where calling <code>x0</code>
delivers in the first two calls <tt class="rst-docutils literal">dimension * [5]</tt> and in
succeeding calls``dimension * [0.01]``. Only the initial value of
0.01 solves the Rastrigin function:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> cma
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">class</span> <span class="py-defname">X0</span>:
<span class="py-more">... </span>    <span class="py-keyword">def</span> <span class="py-defname">__init__</span>(self, dimension):
<span class="py-more">... </span>        self.irun = 0
<span class="py-more">... </span>        self.dimension = dimension
<span class="py-more">... </span>    <span class="py-keyword">def</span> <span class="py-defname">__call__</span>(self):
<span class="py-more">...</span>
<span class="py-more">... </span>        self.irun += 1
<span class="py-more">... </span>        return (self.dimension * [5] <span class="py-keyword">if</span> self.irun &lt; 3
<span class="py-more">... </span>                <span class="py-keyword">else</span> self.dimension * [0.01])
<span class="py-prompt">&gt;&gt;&gt; </span>xopt, es = cma.fmin2(cma.ff.rastrigin, X0(3), 0.01,
<span class="py-more">... </span>                     {<span class="py-string">'verbose'</span>:-9}, restarts=1)
<span class="py-prompt">&gt;&gt;&gt; </span>assert es.result.fbest &gt; 1e-5
<span class="py-prompt">&gt;&gt;&gt; </span>xopt, es = cma.fmin2(cma.ff.rastrigin, X0(3), 0.01,
<span class="py-more">... </span>                     {<span class="py-string">'verbose'</span>:-9}, restarts=2)
<span class="py-prompt">&gt;&gt;&gt; </span>assert es.result.fbest &lt; 1e-5  <span class="py-comment"># third run succeeds due to x0</span></pre><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy._copy_light">
    
  </a>
  <a name="_copy_light">
    
  </a>
  <div class="functionHeader">
    
    def
    _copy_light(self, sigma=None, inopts=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>tentative copy of self, versatile (interface and functionalities may change).</p>
<p><code>sigma</code> overwrites the original initial <code>sigma</code>.
<code>inopts</code> allows to overwrite any of the original options.</p>
<p>This copy may not work as expected depending on the used sampler.</p>
<p>Copy mean and sample distribution parameters and input options. Do
not copy evolution paths, termination status or other state variables.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> cma
<span class="py-prompt">&gt;&gt;&gt; </span>es = cma.CMAEvolutionStrategy(3 * [1], 0.1,
<span class="py-more">... </span>         {<span class="py-string">'verbose'</span>:-9}).optimize(cma.ff.elli, iterations=10)
<span class="py-prompt">&gt;&gt;&gt; </span>es2 = es._copy_light()
<span class="py-prompt">&gt;&gt;&gt; </span>assert es2.sigma == es.sigma
<span class="py-prompt">&gt;&gt;&gt; </span>assert <span class="py-builtin">sum</span>((es.sm.C - es2.sm.C).flat &lt; 1e-12)
<span class="py-prompt">&gt;&gt;&gt; </span>es3 = es._copy_light(sigma=10)
<span class="py-prompt">&gt;&gt;&gt; </span>assert es3.sigma == es3.sigma0 == 10
<span class="py-prompt">&gt;&gt;&gt; </span>es4 = es._copy_light(inopts={<span class="py-string">'CMA_on'</span>: <span class="py-builtin">False</span>})
<span class="py-prompt">&gt;&gt;&gt; </span>assert es4.sp.c1 == es4.sp.cmu == 0</pre><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.ask">
    
  </a>
  <a name="ask">
    
  </a>
  <div class="functionHeader">
    
    def
    ask(self, number=None, xmean=None, sigma_fac=1, gradf=None, args=(), **kwargs):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>get/sample new candidate solutions.</p>
<p>Solutions are sampled from a multi-variate
normal distribution and transformed to f-representation
(phenotype) to be evaluated.</p>
<div class="rst-section" id="rst-arguments">
<h1 class="heading">Arguments</h1>
<blockquote>
<dl class="rst-docutils">
<dt><code>number</code></dt>
<dd>number of returned solutions, by default the
population size <tt class="rst-docutils literal">popsize</tt> (AKA <tt class="rst-docutils literal">lambda</tt>).</dd>
<dt><code>xmean</code></dt>
<dd>distribution mean, phenotyp?</dd>
<dt><code>sigma_fac</code></dt>
<dd>multiplier for internal sample width (standard
deviation)</dd>
<dt><code>gradf</code></dt>
<dd>gradient, <tt class="rst-docutils literal">len(gradf(x)) == len(x)</tt>, if
<tt class="rst-docutils literal">gradf is not None</tt> the third solution in the
returned list is "sampled" in supposedly Newton
direction <tt class="rst-docutils literal">np.dot(C, gradf(xmean, *args))</tt>.</dd>
<dt><code>args</code></dt>
<dd>additional arguments passed to gradf</dd>
</dl>
</blockquote>
</div>
<div class="rst-section" id="rst-return">
<h1 class="heading">Return</h1>
<p>A list of N-dimensional candidate solutions to be evaluated</p>
</div>
<div class="rst-section" id="rst-example">
<h1 class="heading">Example</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> cma
<span class="py-prompt">&gt;&gt;&gt; </span>es = cma.CMAEvolutionStrategy([0,0,0,0], 0.3)  <span class="py-comment">#doctest: +ELLIPSIS</span>
<span class="py-output">(4_w,...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>while <span class="py-keyword">not</span> es.stop() <span class="py-keyword">and</span> es.best.f &gt; 1e-6:
<span class="py-more">... </span>    X = es.ask()  <span class="py-comment"># get list of new solutions</span>
<span class="py-more">... </span>    fit = [cma.ff.rosen(x) <span class="py-keyword">for</span> x <span class="py-keyword">in</span> X]  <span class="py-comment"># call fct with each solution</span>
<span class="py-more">... </span>    es.tell(X, fit)  <span class="py-comment"># feed values</span></pre>
</div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask_and_eval"><code>ask_and_eval</code></a>, <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask_geno"><code>ask_geno</code></a>, <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#tell"><code>tell</code></a></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.ask_geno">
    
  </a>
  <a name="ask_geno">
    
  </a>
  <div class="functionHeader">
    
    def
    ask_geno(self, number=None, xmean=None, sigma_fac=1):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>get new candidate solutions in genotyp.</p>
<p>Solutions are sampled from a multi-variate normal distribution.</p>
<dl class="rst-docutils">
<dt>Arguments are</dt>
<dd><dl class="rst-first rst-last rst-docutils">
<dt><code>number</code></dt>
<dd>number of returned solutions, by default the
population size <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#popsize"><code>popsize</code></a> (AKA lambda).</dd>
<dt><code>xmean</code></dt>
<dd>distribution mean</dd>
<dt><code>sigma_fac</code></dt>
<dd>multiplier for internal sample width (standard
deviation)</dd>
</dl>
</dd>
</dl>
<p><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask_geno"><code>ask_geno</code></a> returns a list of N-dimensional candidate solutions
in genotyp representation and is called by <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask"><code>ask</code></a>.</p>
<p>Details: updates the sample distribution if needed and might
change the geno-pheno transformation during this update.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask"><code>ask</code></a>, <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask_and_eval"><code>ask_and_eval</code></a></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.random_rescale_to_mahalanobis">
    
  </a>
  <a name="random_rescale_to_mahalanobis">
    
  </a>
  <div class="functionHeader">
    
    def
    random_rescale_to_mahalanobis(self, x):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>change <code>x</code> like for injection, all on genotypic level<table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy._random_rescaling_factor_to_mahalanobis_size">
    
  </a>
  <a name="_random_rescaling_factor_to_mahalanobis_size">
    
  </a>
  <div class="functionHeader">
    
    def
    _random_rescaling_factor_to_mahalanobis_size(self, y):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><tt class="rst-docutils literal">self.mean + self._random_rescaling_factor_to_mahalanobis_size(y) * y</tt>
is guarantied to appear like from the sample distribution.<table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.get_mirror">
    
  </a>
  <a name="get_mirror">
    
  </a>
  <div class="functionHeader">
    
    def
    get_mirror(self, x, preserve_length=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>return <tt class="rst-docutils literal">pheno(self.mean - (geno(x) - self.mean))</tt>.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> numpy <span class="py-keyword">as</span> np, cma
<span class="py-prompt">&gt;&gt;&gt; </span>es = cma.CMAEvolutionStrategy(np.random.randn(3), 1)  <span class="py-comment">#doctest: +ELLIPSIS</span>
<span class="py-output">(3_w,...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>x = np.random.randn(3)
<span class="py-prompt">&gt;&gt;&gt; </span>assert cma.utilities.math.Mh.vequals_approximately(es.mean - (x - es.mean), es.get_mirror(x, preserve_length=<span class="py-builtin">True</span>))
<span class="py-prompt">&gt;&gt;&gt; </span>x = es.ask(1)[0]
<span class="py-prompt">&gt;&gt;&gt; </span>vals = (es.get_mirror(x) - es.mean) / (x - es.mean)
<span class="py-prompt">&gt;&gt;&gt; </span>assert cma.utilities.math.Mh.equals_approximately(<span class="py-builtin">sum</span>(vals), <span class="py-builtin">len</span>(vals) * vals[0])</pre>
<p>TODO: this implementation is yet experimental.</p>
<p>TODO: this implementation includes geno-pheno transformation,
however in general GP-transformation should be separated from
specific code.</p>
<p>Selectively mirrored sampling improves to a moderate extend but
overadditively with active CMA for quite understandable reasons.</p>
<p>Optimal number of mirrors are suprisingly small: 1,2,3 for
maxlam=7,13,20 where 3,6,10 are the respective maximal possible
mirrors that must be clearly suboptimal.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.ask_and_eval">
    
  </a>
  <a name="ask_and_eval">
    
  </a>
  <div class="functionHeader">
    
    def
    ask_and_eval(self, func, args=(), gradf=None, number=None, xmean=None, sigma_fac=1, evaluations=1, aggregation=np.median, kappa=1, parallel_mode=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>sample <code>number</code> solutions and evaluate them on <code>func</code>.</p>
<p>Each solution <tt class="rst-docutils literal">s</tt> is resampled until
<tt class="rst-docutils literal">self.is_feasible(s, func(s)) is True</tt>.</p>
<div class="rst-section" id="rst-arguments">
<h1 class="heading">Arguments</h1>
<dl class="rst-docutils">
<dt><code>func</code>:</dt>
<dd>objective function, <tt class="rst-docutils literal">func(x)</tt> accepts a <code>numpy.ndarray</code>
and returns a scalar <tt class="rst-docutils literal">if not parallel_mode</tt>. Else returns a
<a href="http://docs.python.org/library/stdtypes.html#list"><code>list</code></a> of scalars from a <a href="http://docs.python.org/library/stdtypes.html#list"><code>list</code></a> of <code>numpy.ndarray</code>.</dd>
<dt><code>args</code>:</dt>
<dd>additional parameters for <code>func</code></dd>
<dt><code>gradf</code>:</dt>
<dd>gradient of objective function, <tt class="rst-docutils literal">g = gradf(x, *args)</tt>
must satisfy <tt class="rst-docutils literal">len(g) == len(x)</tt></dd>
<dt><code>number</code>:</dt>
<dd>number of solutions to be sampled, by default
population size <tt class="rst-docutils literal">popsize</tt> (AKA lambda)</dd>
<dt><code>xmean</code>:</dt>
<dd>mean for sampling the solutions, by default <tt class="rst-docutils literal">self.mean</tt>.</dd>
<dt><code>sigma_fac</code>:</dt>
<dd>multiplier for sampling width, standard deviation, for example
to get a small perturbation of solution <code>xmean</code></dd>
<dt><code>evaluations</code>:</dt>
<dd>number of evaluations for each sampled solution</dd>
<dt><code>aggregation</code>:</dt>
<dd>function that aggregates <code>evaluations</code> values to
as single value.</dd>
<dt><code>kappa</code>:</dt>
<dd>multiplier used for the evaluation of the solutions, in
that <tt class="rst-docutils literal">func(m + <span class="pre">kappa*(x</span> - m))</tt> is the f-value for <tt class="rst-docutils literal">x</tt>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-return">
<h1 class="heading">Return</h1>
<p><tt class="rst-docutils literal">(X, fit)</tt>, where</p>
<ul class="rst-simple">
<li><code>X</code>: list of solutions</li>
<li><code>fit</code>: list of respective function values</li>
</ul>
</div>
<div class="rst-section" id="rst-details">
<h1 class="heading">Details</h1>
<p>While <tt class="rst-docutils literal">not self.is_feasible(x, func(x))</tt> new solutions are
sampled. By default
<tt class="rst-docutils literal">self.is_feasible == cma.feasible == lambda x, f: f not in (None, np.NaN)</tt>.
The argument to <code>func</code> can be freely modified within <code>func</code>.</p>
<p>Depending on the <tt class="rst-docutils literal">CMA_mirrors</tt> option, some solutions are not
sampled independently but as mirrors of other bad solutions. This
is a simple derandomization that can save 10-30% of the
evaluations in particular with small populations, for example on
the cigar function.</p>
</div>
<div class="rst-section" id="rst-example">
<h1 class="heading">Example</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> cma
<span class="py-prompt">&gt;&gt;&gt; </span>x0, sigma0 = 8 * [10], 1  <span class="py-comment"># 8-D</span>
<span class="py-prompt">&gt;&gt;&gt; </span>es = cma.CMAEvolutionStrategy(x0, sigma0)  <span class="py-comment">#doctest: +ELLIPSIS</span>
<span class="py-output">(5_w,...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>while <span class="py-keyword">not</span> es.stop():
<span class="py-more">... </span>    X, fit = es.ask_and_eval(cma.ff.elli)  <span class="py-comment"># handles NaN with resampling</span>
<span class="py-more">... </span>    es.tell(X, fit)  <span class="py-comment"># pass on fitness values</span>
<span class="py-more">... </span>    es.disp(20) <span class="py-comment"># print every 20-th iteration  #doctest: +ELLIPSIS</span>
<span class="py-output">Iterat #Fevals...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span>(<span class="py-string">'terminated on '</span> + <span class="py-builtin">str</span>(es.stop()))  <span class="py-comment">#doctest: +ELLIPSIS</span>
<span class="py-output">terminated on ...</span></pre>
<p>A single iteration step can be expressed in one line, such that
an entire optimization after initialization becomes:</p>
<pre class="rst-literal-block">
while not es.stop():
    es.tell(*es.ask_and_eval(cma.ff.elli))
</pre>
</div><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy._prepare_injection_directions">
    
  </a>
  <a name="_prepare_injection_directions">
    
  </a>
  <div class="functionHeader">
    
    def
    _prepare_injection_directions(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>provide genotypic directions for TPA and selective mirroring,
with no specific length normalization, to be used in the
coming iteration.</p>
<p>Details:
This method is called in the end of <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#tell"><code>tell</code></a>. The result is
assigned to <tt class="rst-docutils literal">self.pop_injection_directions</tt> and used in
<a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask_geno"><code>ask_geno</code></a>.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.get_selective_mirrors">
    
  </a>
  <a name="get_selective_mirrors">
    
  </a>
  <div class="functionHeader">
    
    def
    get_selective_mirrors(self, number=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>get mirror genotypic directions from worst solutions.</p>
<p>Details:</p>
<p>To be called after the mean has been updated.</p>
<p>Takes the last <tt class="rst-docutils literal">number=sp.lam_mirr</tt> entries in the
<tt class="rst-docutils literal">self.pop[self.fit.idx]</tt> as solutions to be mirrored.</p>
<p>Do not take a mirror if it is suspected to stem from a
previous mirror in order to not go endlessly back and forth.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.tell">
    
  </a>
  <a name="tell">
    
  </a>
  <div class="functionHeader">
    
    def
    tell(self, solutions, function_values, check_points=None, copy=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>pass objective function values to prepare for next
iteration. This core procedure of the CMA-ES algorithm updates
all state variables, in particular the two evolution paths, the
distribution mean, the covariance matrix and a step-size.</p>
<div class="rst-section" id="rst-arguments">
<h1 class="heading">Arguments</h1>
<dl class="rst-docutils">
<dt><code>solutions</code></dt>
<dd>list or array of candidate solution points (of
type <code>numpy.ndarray</code>), most presumably before
delivered by method <code>ask()</code> or <code>ask_and_eval()</code>.</dd>
<dt><code>function_values</code></dt>
<dd>list or array of objective function values
corresponding to the respective points. Beside for termination
decisions, only the ranking of values in <code>function_values</code>
is used.</dd>
<dt><code>check_points</code></dt>
<dd>If <tt class="rst-docutils literal">check_points is None</tt>, only solutions that are not generated
by <code>ask()</code> are possibly clipped (recommended). <tt class="rst-docutils literal">False</tt> does not clip
any solution (not recommended).
If <tt class="rst-docutils literal">True</tt>, clips solutions that realize long steps (i.e. also
those that are unlikely to be generated with <code>ask()</code>). <code>check_points</code>
can be a list of indices to be checked in solutions.</dd>
<dt><a href="http://docs.python.org/library/copy.html#copy"><code>copy</code></a></dt>
<dd><tt class="rst-docutils literal">solutions</tt> can be modified in this routine, if <tt class="rst-docutils literal">copy is False</tt></dd>
</dl>
</div>
<div class="rst-section" id="rst-details">
<h1 class="heading">Details</h1>
<p><code>tell()</code> updates the parameters of the multivariate
normal search distribution, namely covariance matrix and
step-size and updates also the attributes <tt class="rst-docutils literal">countiter</tt> and
<tt class="rst-docutils literal">countevals</tt>. To check the points for consistency is quadratic
in the dimension (like sampling points).</p>
</div>
<div class="rst-section" id="rst-bugs">
<h1 class="heading">Bugs</h1>
<p>The effect of changing the solutions delivered by <code>ask()</code>
depends on whether boundary handling is applied. With boundary
handling, modifications are disregarded. This is necessary to
apply the default boundary handling that uses unrepaired
solutions but might change in future.</p>
</div>
<div class="rst-section" id="rst-example">
<h1 class="heading">Example</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> cma
<span class="py-prompt">&gt;&gt;&gt; </span>func = cma.ff.sphere  <span class="py-comment"># choose objective function</span>
<span class="py-prompt">&gt;&gt;&gt; </span>es = cma.CMAEvolutionStrategy(np.random.rand(2) / 3, 1.5)
<span class="py-more">... </span><span class="py-comment"># doctest:+ELLIPSIS</span>
<span class="py-output">(3_...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>while <span class="py-keyword">not</span> es.stop():
<span class="py-more">... </span>   X = es.ask()
<span class="py-more">... </span>   es.tell(X, [func(x) <span class="py-keyword">for</span> x <span class="py-keyword">in</span> X])
<span class="py-prompt">&gt;&gt;&gt; </span>es.result  <span class="py-comment"># result is a `namedtuple` # doctest:+ELLIPSIS</span>
<span class="py-output">CMAEvolutionStrategyResult(xbest=array([...</span></pre>
</div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">class <a href="cma.evolution_strategy.CMAEvolutionStrategy.html"><code>CMAEvolutionStrategy</code></a>, <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask"><code>ask</code></a>, <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask_and_eval"><code>ask_and_eval</code></a>, <a href="cma.evolution_strategy.html#fmin"><code>fmin</code></a></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.inject">
    
  </a>
  <a name="inject">
    
  </a>
  <div class="functionHeader">
    
    def
    inject(self, solutions, force=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>inject list of one or several genotypic solution(s).</p>
<p>This is the preferable way to pass outside proposal solutions
into <a href="cma.evolution_strategy.CMAEvolutionStrategy.html"><code>CMAEvolutionStrategy</code></a>. Passing (bad) solutions directly
via <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#tell"><code>tell</code></a> is likely to fail when <tt class="rst-docutils literal">CMA_active is True</tt> as by
default.</p>
<p>Unless <tt class="rst-docutils literal">force is True</tt>, the <code>solutions</code> are used as direction
relative to the distribution mean to compute a new candidate
solution returned in method <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask_geno"><code>ask_geno</code></a> which in turn is used in
method <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask"><code>ask</code></a>. Even when <tt class="rst-docutils literal">force is True</tt>, the update in <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#tell"><code>tell</code></a>
takes later care of possibly trimming the update vector.</p>
<p><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#inject"><code>inject</code></a> is to be called before <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#ask"><code>ask</code></a> or after <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#tell"><code>tell</code></a> and can be
called repeatedly.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> cma
<span class="py-prompt">&gt;&gt;&gt; </span>es = cma.CMAEvolutionStrategy(4 * [1], 2)  <span class="py-comment">#doctest: +ELLIPSIS</span>
<span class="py-output">(4_w,...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>while <span class="py-keyword">not</span> es.stop():
<span class="py-more">... </span>    es.inject([4 * [0.0]])
<span class="py-more">... </span>    X = es.ask()
<span class="py-more">... </span>    <span class="py-keyword">if</span> es.countiter == 0:
<span class="py-more">... </span>        assert X[0][0] == X[0][1]  <span class="py-comment"># injected sol. is on the diagonal</span>
<span class="py-more">... </span>    es.tell(X, [cma.ff.sphere(x) <span class="py-keyword">for</span> x <span class="py-keyword">in</span> X])</pre>
<p>Details: injected solutions are not used in the "active" update which
would decrease variance in the covariance matrix in this direction.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.result">
    
  </a>
  <a name="result">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    result(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>return a <a href="cma.evolution_strategy.CMAEvolutionStrategyResult.html"><code>CMAEvolutionStrategyResult</code></a> <code>namedtuple</code>.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><a href="cma.evolution_strategy.CMAEvolutionStrategyResult.html"><code>cma.evolution_strategy.CMAEvolutionStrategyResult</code></a>
or try <tt class="rst-docutils literal"><span class="pre">help(...result)</span></tt> on the <tt class="rst-docutils literal">result</tt> property
of an <a href="cma.evolution_strategy.CMAEvolutionStrategy.html"><code>CMAEvolutionStrategy</code></a> instance or on the
<a href="cma.evolution_strategy.CMAEvolutionStrategyResult.html"><code>CMAEvolutionStrategyResult</code></a> instance itself.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.result_pretty">
    
  </a>
  <a name="result_pretty">
    
  </a>
  <div class="functionHeader">
    
    def
    result_pretty(self, number_of_runs=0, time_str=None, fbestever=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>pretty print result.</p>
<p>Returns <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#result"><code>result</code></a> of <tt class="rst-docutils literal">self</tt>.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.pickle_dumps">
    
  </a>
  <a name="pickle_dumps">
    
  </a>
  <div class="functionHeader">
    
    def
    pickle_dumps(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>return <tt class="rst-docutils literal">pickle.dumps(self)</tt>,</p>
<p>if necessary remove unpickleable (and also unnecessary) local
function reference beforehand.</p>
<p>The resulting <a href="http://docs.python.org/library/stdtypes.html#bytes"><code>bytes</code></a> string-object can be saved to a file like:</p>
<pre class="rst-literal-block">
import cma
es = cma.CMAEvolutionStrategy(3 * [1], 1)
es.optimize(cma.ff.elli, iterations=22)
filename = 'es-pickle-test'
open(filename, 'wb').write(es.pickle_dumps())
</pre>
<p>and recovered like:</p>
<pre class="rst-literal-block">
import pickle
es = pickle.load(open(filename, 'rb'))
</pre>
<p>or:</p>
<pre class="rst-literal-block">
es = pickle.loads(open(filename, 'rb').read())
es.optimize(cma.ff.elli, iterations=22)  # continue optimizing
</pre><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.repair_genotype">
    
  </a>
  <a name="repair_genotype">
    
  </a>
  <div class="functionHeader">
    
    def
    repair_genotype(self, x, copy_if_changed=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>make sure that solutions fit to the sample distribution.</p>
<p>This interface is versatile and likely to change.</p>
<p>The Mahalanobis distance <tt class="rst-docutils literal">x - self.mean</tt> is clipping at
<tt class="rst-docutils literal"><span class="pre">N**0.5</span> + 2 * N / (N + 2)</tt>, but the specific repair
mechanism may change in future.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.manage_plateaus">
    
  </a>
  <a name="manage_plateaus">
    
  </a>
  <div class="functionHeader">
    
    def
    manage_plateaus(self, sigma_fac=1.5, sample_fraction=0.5):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>increase <code>sigma</code> by <code>sigma_fac</code> in case of a plateau.</p>
<p>A plateau is assumed to be present if the best sample and
<tt class="rst-docutils literal">popsize * sample_fraction</tt>-th best sample have the same
fitness.</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> cma
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">def</span> <span class="py-defname">f</span>(X):
<span class="py-more">... </span>    return (<span class="py-builtin">len</span>(X) - 1) * [1] + [2]
<span class="py-prompt">&gt;&gt;&gt; </span>es = cma.CMAEvolutionStrategy(4 * [0], 5, {<span class="py-string">'verbose'</span>:-9, <span class="py-string">'tolflatfitness'</span>:1e4})
<span class="py-prompt">&gt;&gt;&gt; </span>while <span class="py-keyword">not</span> es.stop():
<span class="py-more">... </span>    X = es.ask()
<span class="py-more">... </span>    es.tell(X, f(X))
<span class="py-more">... </span>    es.manage_plateaus()
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">if</span> es.sigma &lt; 1.5**es.countiter: <span class="py-keyword">print</span>((es.sigma, 1.5**es.countiter, es.stop()))</pre><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.condition_number">
    
  </a>
  <a name="condition_number">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    condition_number(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>condition number of the statistical-model sampler.</p>
<p>Details: neither encoding/decoding from <code>sigma_vec</code>-scaling nor
<code>gp</code>-transformation are taken into account for this computation.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.alleviate_conditioning_in_coordinates">
    
  </a>
  <a name="alleviate_conditioning_in_coordinates">
    
  </a>
  <div class="functionHeader">
    
    def
    alleviate_conditioning_in_coordinates(self, condition=100000000.0):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>pass scaling from <code>C</code> to <code>sigma_vec</code>.</p>
<p>As a result, <code>C</code> is a correlation matrix, i.e., all diagonal
entries of <code>C</code> are <code>1</code>.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy._tfp">
    
  </a>
  <a name="_tfp">
    
  </a>
  <div class="functionHeader">
    
    def
    _tfp(self, x):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod private">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy._tfg">
    
  </a>
  <a name="_tfg">
    
  </a>
  <div class="functionHeader">
    
    def
    _tfg(self, x):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.alleviate_conditioning">
    
  </a>
  <a name="alleviate_conditioning">
    
  </a>
  <div class="functionHeader">
    
    def
    alleviate_conditioning(self, condition=1000000000000.0):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>pass conditioning of <code>C</code> to linear transformation in <code>self.gp</code>.</p>
<p>Argument <code>condition</code> defines the limit condition number above
which the action is taken.</p>
<p>Details: the action applies only if <code>self.gp.isidentity</code>. Then,
the covariance matrix <code>C</code> is set (back) to identity and a
respective linear transformation is "added" to <code>self.gp</code>.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy._updateBDfromSM">
    
  </a>
  <a name="_updateBDfromSM">
    
  </a>
  <div class="functionHeader">
    
    def
    _updateBDfromSM(self, sm_=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>helper function for a smooth transition to sampling classes.</p>
<p>By now all tests run through without this method in effect.
Gradient injection and noeffectaxis however rely on the
non-documented attributes B and D in the sampler.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.feed_for_resume">
    
  </a>
  <a name="feed_for_resume">
    
  </a>
  <div class="functionHeader">
    
    def
    feed_for_resume(self, X, function_values):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Resume a run using the solution history.</p>
<p>CAVEAT: this hasn't been thoroughly tested or in intensive use.</p>
<p>Given all "previous" candidate solutions and their respective
function values, the state of a <a href="cma.evolution_strategy.CMAEvolutionStrategy.html"><code>CMAEvolutionStrategy</code></a> object
can be reconstructed from this history. This is the purpose of
function <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#feed_for_resume"><code>feed_for_resume</code></a>.</p>
<div class="rst-section" id="rst-arguments">
<h1 class="heading">Arguments</h1>
<dl class="rst-docutils">
<dt><code>X</code>:</dt>
<dd>(all) solution points in chronological order, phenotypic
representation. The number of points must be a multiple
of popsize.</dd>
<dt><code>function_values</code>:</dt>
<dd>respective objective function values</dd>
</dl>
</div>
<div class="rst-section" id="rst-details">
<h1 class="heading">Details</h1>
<p><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#feed_for_resume"><code>feed_for_resume</code></a> can be called repeatedly with only parts of
the history. The part must have the length of a multiple
of the population size.
<a href="cma.evolution_strategy.CMAEvolutionStrategy.html#feed_for_resume"><code>feed_for_resume</code></a> feeds the history in popsize-chunks into <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#tell"><code>tell</code></a>.
The state of the random number generator might not be
reconstructed, but this would be only relevant for the future.</p>
</div>
<div class="rst-section" id="rst-example">
<h1 class="heading">Example</h1>
<pre class="rst-literal-block">
import cma

# prepare
(x0, sigma0) = ... # initial values from previous trial
X = ... # list of generated solutions from a previous trial
f = ... # respective list of f-values

# resume
es = cma.CMAEvolutionStrategy(x0, sigma0)
es.feed_for_resume(X, f)

# continue with func as objective function
while not es.stop():
    X = es.ask()
    es.tell(X, [func(x) for x in X])
</pre>
<p>Credits to Dirk Bueche and Fabrice Marchal for the feeding idea.</p>
</div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">class <a href="cma.evolution_strategy.CMAEvolutionStrategy.html"><code>CMAEvolutionStrategy</code></a> for a simple dump/load
to resume.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.mahalanobis_norm">
    
  </a>
  <a name="mahalanobis_norm">
    
  </a>
  <div class="functionHeader">
    
    def
    mahalanobis_norm(self, dx):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>return Mahalanobis norm based on the current sample
distribution.</p>
<p>The norm is based on Covariance matrix <tt class="rst-docutils literal">C</tt> times <tt class="rst-docutils literal"><span class="pre">sigma**2</span></tt>,
and includes <tt class="rst-docutils literal">sigma_vec</tt>. The expected Mahalanobis distance to
the sample mean is about <tt class="rst-docutils literal">sqrt(dimension)</tt>.</p>
<div class="rst-section" id="rst-argument">
<h1 class="heading">Argument</h1>
<p>A <em>genotype</em> difference <code>dx</code>.</p>
</div>
<div class="rst-section" id="rst-example">
<h1 class="heading">Example</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> cma, numpy
<span class="py-prompt">&gt;&gt;&gt; </span>es = cma.CMAEvolutionStrategy(numpy.ones(10), 1)  <span class="py-comment">#doctest: +ELLIPSIS</span>
<span class="py-output">(5_w,...</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>xx = numpy.random.randn(2, 10)
<span class="py-prompt">&gt;&gt;&gt; </span>d = es.mahalanobis_norm(es.gp.geno(xx[0]-xx[1]))</pre>
<p><code>d</code> is the distance "in" the true sample distribution,
sampled points have a typical distance of <tt class="rst-docutils literal">sqrt(2*es.N)</tt>,
where <tt class="rst-docutils literal">es.N</tt> is the dimension, and an expected distance of
close to <tt class="rst-docutils literal">sqrt(N)</tt> to the sample mean. In the example,
<code>d</code> is the Euclidean distance, because C = I and sigma = 1.</p>
</div><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.isotropic_mean_shift">
    
  </a>
  <a name="isotropic_mean_shift">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    isotropic_mean_shift(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>normalized last mean shift, under random selection N(0,I)</p>
<p>distributed.</p>
<p>Caveat: while it is finite and close to sqrt(n) under random
selection, the length of the normalized mean shift under
<em>systematic</em> selection (e.g. on a linear function) tends to
infinity for mueff -&gt; infty. Hence it must be used with great
care for large mueff.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.disp_annotation">
    
  </a>
  <a name="disp_annotation">
    
  </a>
  <div class="functionHeader">
    
    def
    disp_annotation(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>print annotation line for <a href="cma.evolution_strategy.CMAEvolutionStrategy.html#disp"><code>disp</code></a> ()<table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.disp">
    
  </a>
  <a name="disp">
    
  </a>
  <div class="functionHeader">
    
    def
    disp(self, modulo=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>print current state variables in a single-line.</p>
<p>Prints only if <tt class="rst-docutils literal">iteration_counter % modulo == 0</tt>.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><a href="cma.evolution_strategy.CMAEvolutionStrategy.html#disp_annotation"><code>disp_annotation</code></a>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="cma.evolution_strategy.CMAEvolutionStrategy.plot">
    
  </a>
  <a name="plot">
    
  </a>
  <div class="functionHeader">
    
    def
    plot(self, *args, **kwargs):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>plot current state variables using <code>matplotlib</code>.</p>
<p>Details: calls <code>self.logger.plot</code>.</p><table class="fieldTable"></table></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for cma, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> at 2020-04-19 17:54:08.
      </address>

    </div>

    <script type="text/javascript" src="pydoctor.js"></script>

  </body>
</html>